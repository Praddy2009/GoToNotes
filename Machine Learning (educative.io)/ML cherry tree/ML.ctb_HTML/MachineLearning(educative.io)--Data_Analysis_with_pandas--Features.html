<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Features</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Features</h1><br/><br /><h3>Chapter Goals:</h3><br />  • Understand the difference between quantitative and categorical features<br />  • Learn methods to manipulate features and add them to a DataFrame<br />  • Write code to add MLB statistics to a DataFrame<br /><br /><strong><h3>Quantitative vs. categorical</h3></strong><br />We often refer to the columns of a DataFrame as the <em>features</em> of the dataset that it represents. These features can be quantitative or categorical.<br />A quantitative feature,  e.g. height or weight, is a feature that can be measured numerically.  These are features we could calculate the sum, mean, or other numerical  metrics for.<br />A categorical feature,  e.g. gender or birthplace, is one where the values are categories that  could be used to group the dataset. These are the features we would use  with the <code>groupby</code> function from the previous chapter.<br />Some features can be both  quantitative or categorical, depending on the context they are used. For  example, we could use year of birth as a quantitative feature if we  were trying to find statistics such as the average birth year for a  particular dataset. On the other hand, we could also use it as a  categorical feature and group the data by the different years of birth.<br /><br />~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><strong><h3>Quantitative features</h3></strong><br />In the previous chapter,  we focused on grouping a dataset by its categorical features. We'll now  describe methods for dealing with quantitative features.<br />Two of the most important functions to use with quantitative features are <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sum.html">sum</a> and <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.mean.html">mean</a>. In the previous chapter we also introduced <code>sum</code> and <code>mean</code> functions, which were used to aggregate quantitative features for each a group.<br />However, while the functions from the previous chapter were applied to the output of <code>groupby</code>, the ones we use in this chapter are applied to individual DataFrames.<br />The code below shows example usages of <code>sum</code> and <code>mean</code>. The <code>df</code>  DataFrame represents three different speed tests (columns) for three  different processors (rows). The data values correspond to the seconds  taken for a given speed test and processor.<br /><br /><img src="images/12-1.png" alt="images/12-1.png" />     <img src="images/12-2.png" alt="images/12-2.png" /><br /><br />Neither function takes in a required argument. The most commonly used keyword argument for both functions is <code>axis</code>. The <code>axis</code> argument specifies whether to aggregate over rows (<code>axis=0</code>, the default), or columns (<code>axis=1</code>).<br />In the code example, we  used a DataFrame representing speed tests for three different processors  (measured in seconds). When we used no argument, equivalent to using <code>axis=0</code>, the <code>sum</code> and <code>mean</code> functions calculated total and average times for each test. When we used <code>axis=1</code>, the <code>sum</code> and <code>mean</code> functions calculated total and average test times (across all three tests) for each processor.<br /><br /><h3>C. Weighted features</h3><br />Along with aggregating quantitative features, we can also apply weights to them. We do this through the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.multiply.html">multiply</a> function.<br />The <code>multiply</code>  function takes in a list of weights or a constant as its required  argument. If a constant is used, the constant is multiplied across all  the rows or columns (depending on the value of <code>axis</code>). If a list is used, then the position of each weight in the list corresponds to which row/column it is multiplied to.<br />In contrast with <code>sum</code> and <code>mean</code>, the default <code>axis</code> for <code>multiply</code> is the columns axis. Therefore, to multiply weights along the rows of a DataFrame, we need to explicitly set <code>axis=0</code>.<br />The code below shows example usages of <code>multiply</code>. The <code>df</code> DataFrame represents three different speed tests (columns) for two different processors (rows).<br /><br /><img src="images/12-3.png" alt="images/12-3.png" />  <img src="images/12-4.png" alt="images/12-4.png" /><br /><br />In the code above, the test times for processor <code>'p1'</code> were measured in seconds, while the times for <code>'p2'</code> were in milliseconds. So we made all the times in milliseconds by multiplying the values of <code>'p1'</code> by <code>1000</code>.<br />Then we multiplied the values in <code>'T2'</code> by <code>0.5</code>, since those tests were done with two processors rather than one. This makes the final <code>sum</code> a <em>weighted sum</em> across the three columns.<br /><br /></div></body></html>